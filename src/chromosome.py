# Project: VUT FIT BIN - Neuroevolution
# Author: Marek Sarvas
# Login: xsarva00                   
# Date: 2021/2022                       
# Module: Class representing individual in EA population

import torch
import torch.nn as nn
import numpy as np


class Chromosome(nn.Module):
    """ Class representing neural network generated by EA according to given genotype.
    """

    def __init__(self, stages, nodes, genotype,dataset="mnist", num_classes=10):
        super(Chromosome, self).__init__()
        self.genotype = genotype
        self.S = stages  # number of stages
        self.K = nodes  # number of convolution layers in each stage

        # NN layer parameters
        self.out_channels = 32
        self.in_channels = 32
        if dataset == "cifar10":
            self.init_in_channels = 3
            self.input_size = 32 
            if stages == 2:
                self.flat_feat = 4096 
            else:
                self.flat_feat = 2048 
        else:
            self.init_in_channels = 1
            self.input_size = 28 
            if stages == 2:
                self.flat_feat = 3136 
            else:
                self.flat_feat = 1152
        self.default_kernel_size = 5
        self.kernel_size = 3
        
        # NN layers
        self.cnn_stages = self.create_cnn_stages()
        self.between_stage = nn.Sequential(
            nn.MaxPool2d(kernel_size=2),
            nn.ReLU(inplace=False)
        )
        self.fin_linear = nn.Sequential(
                nn.Dropout(0.1),
                nn.Linear(self.flat_feat, num_classes)
        )
    

    def create_cnn_stages(self):
        """ Create structure containing K nodes that will be connected
            according to the chromosome value.
        """
        stages = nn.ModuleList([])
        first_in_channels = self.in_channels

        # generate stages -> modules containing differently connected 
        # con2d layers according to the genes
        for stage in range(self.S):
            # first stage has differemt number of input channels
            if stage == 0:
                stages.append(Stage(self.K[stage], self.in_channels, self.init_in_channels, self.out_channels, self.kernel_size, self.default_kernel_size, self.genotype[stage])) 
            else:
                stages.append(Stage(self.K[stage], self.in_channels, first_in_channels, self.out_channels, self.kernel_size, self.default_kernel_size, self.genotype[stage])) 
                first_in_channels = first_in_channels * 2

            self.in_channels = self.in_channels * 2
            self.out_channels = self.out_channels * 2
        return stages 

    def forward(self, x):
        for stage in self.cnn_stages:
            x = stage(x)
            x = self.between_stage(x)

        x = torch.flatten(x, 1)
        x = self.fin_linear(x)
        x = torch.softmax(x, dim=1)
        return x



class MyConv2d(nn.Module):
    """ Custom module for convolution to store booleans used in dynamic NN construction.
    """
    def __init__(self, in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros', device=None, dtype=None):
        super(MyConv2d, self).__init__()
        self.has_input_connection = False  # current conv layer is used in computation
        self.has_output_connection = False # output is used, if False output is used as part of an input into last default conv layer in current stage
        self.conv = nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, padding=padding)

    def forward(self,x):
        return self.conv(x)


class Stage(nn.Module):
    """ Torch module implementing layers and logic for each stage of NN, it consists of K conv layers + 2 default (beginning and end).
        Conv2d layer connections in forward function are constructed according to genotype for current stage.
    """
    def __init__(self, K, in_channels, init_in_channels, out_channels, kernel_size, default_kernel_size, genotype):
        super(Stage, self).__init__()
        self.nodes = nn.ModuleList([])
        self.stage_genotype = genotype
        self.K = K
        self.def_input_node = nn.Conv2d(in_channels=init_in_channels, out_channels=out_channels, kernel_size=default_kernel_size, padding=2)

        for _ in range(K):
            self.nodes.append(MyConv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, padding=1))
    
        self.def_output_node = nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, padding=1)
        self.b_norm = nn.BatchNorm2d(out_channels)
    
    def forward(self, x):
        x = self.def_input_node(x)

        # if no connections are made, only first default Conv layer is used
        if not self.check_for_connection():
            return self.b_norm(x)
        tmp_outputs = []
        
        # prepare variable for storing cumulative outputs/residual connections
        for _ in range(self.K):
            tmp_outputs.append(0)

        tmp_outputs[0] = self.nodes[0](x) 
        
        # loop through each node in current stage
        for node_idx, node_connection in enumerate(self.stage_genotype):
            # loop through each connection from previous layers into current
            for input_node_idx, bit in enumerate(node_connection):
                if bit == '1':
                    tmp_outputs[node_idx+1] += tmp_outputs[input_node_idx] 
                    self.nodes[input_node_idx].has_output_connection = True
                    self.nodes[input_node_idx].has_input_connection = True
            
            
            # if no connection use output of default first layer
            if not torch.is_tensor(tmp_outputs[node_idx+1]):
                tmp_outputs[node_idx+1] = x

            if self.nodes[node_idx+1].has_input_connection:
                tmp_outputs[node_idx+1] = self.nodes[node_idx+1](tmp_outputs[node_idx+1])

        # sum all used layers that dont output connection and connect them into default last convolution layer
        for i in range(self.K-1):
            if not self.nodes[i].has_output_connection and self.nodes[i].has_input_connection:
                tmp_outputs[-1] += tmp_outputs[i] 

        x = self.def_output_node(tmp_outputs[-1])
        return self.b_norm(x)

    def check_for_connection(self):
        for node_c in self.stage_genotype:
            if '1' in node_c: return True
        return False

